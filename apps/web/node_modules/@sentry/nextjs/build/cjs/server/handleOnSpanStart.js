Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });

const api = require('@opentelemetry/api');
const semanticConventions = require('@opentelemetry/semantic-conventions');
const core = require('@sentry/core');
const opentelemetry = require('@sentry/opentelemetry');
const nextSpanAttributes = require('../common/nextSpanAttributes.js');
const addHeadersAsAttributes = require('../common/utils/addHeadersAsAttributes.js');
const dropMiddlewareTunnelRequests = require('../common/utils/dropMiddlewareTunnelRequests.js');
const tracingUtils = require('../common/utils/tracingUtils.js');

/**
 * Handles the on span start event for Next.js spans.
 * This function is used to enhance the span with additional information such as the route, the method, the headers, etc.
 * It is called for every span that is started by Next.js.
 * @param span The span that is starting.
 */
function handleOnSpanStart(span) {
  const spanAttributes = core.spanToJSON(span).data;
  const rootSpan = core.getRootSpan(span);
  const rootSpanAttributes = core.spanToJSON(rootSpan).data;
  const isRootSpan = span === rootSpan;

  dropMiddlewareTunnelRequests.dropMiddlewareTunnelRequests(span, spanAttributes);

  // What we do in this glorious piece of code, is hoist any information about parameterized routes from spans emitted
  // by Next.js via the `next.route` attribute, up to the transaction by setting the http.route attribute.
  if (typeof spanAttributes?.[nextSpanAttributes.ATTR_NEXT_ROUTE] === 'string') {
    // Only hoist the http.route attribute if the transaction doesn't already have it
    if (
      // eslint-disable-next-line deprecation/deprecation
      (rootSpanAttributes?.[semanticConventions.ATTR_HTTP_REQUEST_METHOD] || rootSpanAttributes?.[semanticConventions.SEMATTRS_HTTP_METHOD]) &&
      !rootSpanAttributes?.[semanticConventions.ATTR_HTTP_ROUTE]
    ) {
      const route = spanAttributes[nextSpanAttributes.ATTR_NEXT_ROUTE].replace(/\/route$/, '');
      rootSpan.updateName(route);
      rootSpan.setAttribute(semanticConventions.ATTR_HTTP_ROUTE, route);
      // Preserving the original attribute despite internally not depending on it
      rootSpan.setAttribute(nextSpanAttributes.ATTR_NEXT_ROUTE, route);
    }
  }

  if (spanAttributes?.[nextSpanAttributes.ATTR_NEXT_SPAN_TYPE] === 'Middleware.execute') {
    const middlewareName = spanAttributes[nextSpanAttributes.ATTR_NEXT_SPAN_NAME];
    if (typeof middlewareName === 'string') {
      rootSpan.updateName(middlewareName);
      rootSpan.setAttribute(semanticConventions.ATTR_HTTP_ROUTE, middlewareName);
      rootSpan.setAttribute(nextSpanAttributes.ATTR_NEXT_SPAN_NAME, middlewareName);
    }
    span.setAttribute(core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, 'auto');
  }

  // We want to skip span data inference for any spans generated by Next.js. Reason being that Next.js emits spans
  // with patterns (e.g. http.server spans) that will produce confusing data.
  if (spanAttributes?.[nextSpanAttributes.ATTR_NEXT_SPAN_TYPE] !== undefined) {
    span.setAttribute(core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, 'auto');
  }

  if (isRootSpan) {
    const headers = core.getIsolationScope().getScopeData().sdkProcessingMetadata?.normalizedRequest?.headers;
    addHeadersAsAttributes.addHeadersAsAttributes(headers, rootSpan);
  }

  // We want to fork the isolation scope for incoming requests
  if (spanAttributes?.[nextSpanAttributes.ATTR_NEXT_SPAN_TYPE] === 'BaseServer.handleRequest' && isRootSpan) {
    const scopes = core.getCapturedScopesOnSpan(span);

    const isolationScope = (scopes.isolationScope || core.getIsolationScope()).clone();
    const scope = scopes.scope || core.getCurrentScope();

    const currentScopesPointer = opentelemetry.getScopesFromContext(api.context.active());
    if (currentScopesPointer) {
      currentScopesPointer.isolationScope = isolationScope;
    }

    core.setCapturedScopesOnSpan(span, scope, isolationScope);
  }

  tracingUtils.maybeEnhanceServerComponentSpanName(span, spanAttributes, rootSpanAttributes);
}

exports.handleOnSpanStart = handleOnSpanStart;
//# sourceMappingURL=handleOnSpanStart.js.map
