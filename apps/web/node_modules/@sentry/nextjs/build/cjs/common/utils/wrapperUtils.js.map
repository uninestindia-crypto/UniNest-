{"version":3,"file":"wrapperUtils.js","sources":["../../../../src/common/utils/wrapperUtils.ts"],"sourcesContent":["import {\n  captureException,\n  getActiveSpan,\n  getCurrentScope,\n  getIsolationScope,\n  getRootSpan,\n  getTraceData,\n  httpRequestToRequestData,\n  isThenable,\n} from '@sentry/core';\nimport type { IncomingMessage, ServerResponse } from 'http';\nimport { TRANSACTION_ATTR_SENTRY_ROUTE_BACKFILL } from '../span-attributes-with-logic-attached';\n\n/**\n * Wraps a function that potentially throws. If it does, the error is passed to `captureException` and rethrown.\n *\n * Note: This function turns the wrapped function into an asynchronous one.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function withErrorInstrumentation<F extends (...args: any[]) => any>(\n  origFunction: F,\n): (...params: Parameters<F>) => Promise<ReturnType<F>> {\n  return async function (this: unknown, ...origFunctionArguments: Parameters<F>): Promise<ReturnType<F>> {\n    try {\n      return await origFunction.apply(this, origFunctionArguments);\n    } catch (e) {\n      // TODO: Extract error logic from `withSentry` in here or create a new wrapper with said logic or something like that.\n      captureException(e, {\n        // TODO: check if origFunction.name actually returns the correct name or minified garbage\n        // in this case, we can add another argument to this wrapper with the respective function name\n        mechanism: { handled: false, type: 'auto.function.nextjs.wrapped', data: { function: origFunction.name } },\n      });\n      throw e;\n    }\n  };\n}\n\n/**\n * Calls a server-side data fetching function (that takes a `req` and `res` object in its context) with tracing\n * instrumentation. A transaction will be created for the incoming request (if it doesn't already exist) in addition to\n * a span for the wrapped data fetching function.\n *\n * All of the above happens in an isolated domain, meaning all thrown errors will be associated with the correct span.\n *\n * @param origDataFetcher The data fetching method to call.\n * @param origFunctionArguments The arguments to call the data fetching method with.\n * @param req The data fetching function's request object.\n * @param res The data fetching function's response object.\n * @param options Options providing details for the created transaction and span.\n * @returns what the data fetching method call returned.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function withTracedServerSideDataFetcher<F extends (...args: any[]) => Promise<any> | any>(\n  origDataFetcher: F,\n  req: IncomingMessage,\n  res: ServerResponse,\n  options: {\n    /** Parameterized route of the request - will be used for naming the transaction. */\n    requestedRouteName: string;\n    /** Name of the route the data fetcher was defined in - will be used for describing the data fetcher's span. */\n    dataFetcherRouteName: string;\n    /** Name of the data fetching method - will be used for describing the data fetcher's span. */\n    dataFetchingMethodName: string;\n  },\n): (...params: Parameters<F>) => Promise<{ data: ReturnType<F>; sentryTrace?: string; baggage?: string }> {\n  return async function (\n    this: unknown,\n    ...args: Parameters<F>\n  ): Promise<{ data: ReturnType<F>; sentryTrace?: string; baggage?: string }> {\n    const normalizedRequest = httpRequestToRequestData(req);\n    getCurrentScope().setTransactionName(`${options.dataFetchingMethodName} (${options.dataFetcherRouteName})`);\n    getIsolationScope().setSDKProcessingMetadata({ normalizedRequest });\n\n    const span = getActiveSpan();\n\n    // Only set the route backfill if the span is not for /_error\n    if (span && options.requestedRouteName !== '/_error') {\n      const root = getRootSpan(span);\n      root.setAttribute(TRANSACTION_ATTR_SENTRY_ROUTE_BACKFILL, options.requestedRouteName);\n    }\n\n    const { 'sentry-trace': sentryTrace, baggage } = getTraceData();\n\n    return {\n      sentryTrace: sentryTrace,\n      baggage: baggage,\n      data: await origDataFetcher.apply(this, args),\n    };\n  };\n}\n\n/**\n * Call a data fetcher and trace it. Only traces the function if there is an active transaction on the scope.\n *\n * We only do the following until we move transaction creation into this function: When called, the wrapped function\n * will also update the name of the active transaction with a parameterized route provided via the `options` argument.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport async function callDataFetcherTraced<F extends (...args: any[]) => Promise<any> | any>(\n  origFunction: F,\n  origFunctionArgs: Parameters<F>,\n): Promise<ReturnType<F>> {\n  try {\n    return await origFunction(...origFunctionArgs);\n  } catch (e) {\n    captureException(e, { mechanism: { handled: false, type: 'auto.function.nextjs.data_fetcher' } });\n    throw e;\n  }\n}\n\n/**\n * Extracts the params and searchParams from the props object.\n *\n * Depending on the next version, params and searchParams may be a promise which we do not want to resolve in this function.\n */\nexport function maybeExtractSynchronousParamsAndSearchParams(props: unknown): {\n  params: Record<string, string> | undefined;\n  searchParams: Record<string, string> | undefined;\n} {\n  let params =\n    props && typeof props === 'object' && 'params' in props\n      ? (props.params as Record<string, string> | Promise<Record<string, string>> | undefined)\n      : undefined;\n  if (isThenable(params)) {\n    params = undefined;\n  }\n\n  let searchParams =\n    props && typeof props === 'object' && 'searchParams' in props\n      ? (props.searchParams as Record<string, string> | Promise<Record<string, string>> | undefined)\n      : undefined;\n  if (isThenable(searchParams)) {\n    searchParams = undefined;\n  }\n\n  return { params, searchParams };\n}\n"],"names":["captureException","httpRequestToRequestData","getCurrentScope","getIsolationScope","getActiveSpan","getRootSpan","TRANSACTION_ATTR_SENTRY_ROUTE_BACKFILL","getTraceData"],"mappings":";;;;;AAaA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,wBAAwB;AACxC,EAAE,YAAY;AACd,EAAwD;AACxD,EAAE,OAAO,iBAA+B,GAAG,qBAAqB,EAAyC;AACzG,IAAI,IAAI;AACR,MAAM,OAAO,MAAM,YAAY,CAAC,KAAK,CAAC,IAAI,EAAE,qBAAqB,CAAC;AAClE,IAAI,CAAA,CAAE,OAAO,CAAC,EAAE;AAChB;AACA,MAAMA,qBAAgB,CAAC,CAAC,EAAE;AAC1B;AACA;AACA,QAAQ,SAAS,EAAE,EAAE,OAAO,EAAE,KAAK,EAAE,IAAI,EAAE,8BAA8B,EAAE,IAAI,EAAE,EAAE,QAAQ,EAAE,YAAY,CAAC,IAAA,IAAQ;AAClH,OAAO,CAAC;AACR,MAAM,MAAM,CAAC;AACb,IAAI;AACJ,EAAE,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,+BAA+B;AAC/C,EAAE,eAAe;AACjB,EAAE,GAAG;AACL,EAAE,GAAG;AACL,EAAE;;AAOA;AACF,EAA0G;AAC1G,EAAE,OAAO;;AAET,IAAI,GAAG;AACP,IAA8E;AAC9E,IAAI,MAAM,iBAAA,GAAoBC,6BAAwB,CAAC,GAAG,CAAC;AAC3D,IAAIC,oBAAe,EAAE,CAAC,kBAAkB,CAAC,CAAC,EAAA,OAAA,CAAA,sBAAA,CAAA,EAAA,EAAA,OAAA,CAAA,oBAAA,CAAA,CAAA,CAAA,CAAA;AACA,IAAAC,sBAAA,EAAA,CAAA,wBAAA,CAAA,EAAA,iBAAA,EAAA,CAAA;;AAEA,IAAA,MAAA,IAAA,GAAAC,kBAAA,EAAA;;AAEA;AACA,IAAA,IAAA,IAAA,IAAA,OAAA,CAAA,kBAAA,KAAA,SAAA,EAAA;AACA,MAAA,MAAA,IAAA,GAAAC,gBAAA,CAAA,IAAA,CAAA;AACA,MAAA,IAAA,CAAA,YAAA,CAAAC,sEAAA,EAAA,OAAA,CAAA,kBAAA,CAAA;AACA,IAAA;;AAEA,IAAA,MAAA,EAAA,cAAA,EAAA,WAAA,EAAA,OAAA,EAAA,GAAAC,iBAAA,EAAA;;AAEA,IAAA,OAAA;AACA,MAAA,WAAA,EAAA,WAAA;AACA,MAAA,OAAA,EAAA,OAAA;AACA,MAAA,IAAA,EAAA,MAAA,eAAA,CAAA,KAAA,CAAA,IAAA,EAAA,IAAA,CAAA;AACA,KAAA;AACA,EAAA,CAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAA,qBAAA;AACA,EAAA,YAAA;AACA,EAAA,gBAAA;AACA,EAAA;AACA,EAAA,IAAA;AACA,IAAA,OAAA,MAAA,YAAA,CAAA,GAAA,gBAAA,CAAA;AACA,EAAA,CAAA,CAAA,OAAA,CAAA,EAAA;AACA,IAAAP,qBAAA,CAAA,CAAA,EAAA,EAAA,SAAA,EAAA,EAAA,OAAA,EAAA,KAAA,EAAA,IAAA,EAAA,mCAAA,EAAA,EAAA,CAAA;AACA,IAAA,MAAA,CAAA;AACA,EAAA;AACA;;;;;;"}