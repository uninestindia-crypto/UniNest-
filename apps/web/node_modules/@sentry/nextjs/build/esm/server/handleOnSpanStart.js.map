{"version":3,"file":"handleOnSpanStart.js","sources":["../../../src/server/handleOnSpanStart.ts"],"sourcesContent":["import { context } from '@opentelemetry/api';\nimport { ATTR_HTTP_REQUEST_METHOD, ATTR_HTTP_ROUTE, SEMATTRS_HTTP_METHOD } from '@opentelemetry/semantic-conventions';\nimport type { Span } from '@sentry/core';\nimport {\n  getCapturedScopesOnSpan,\n  getCurrentScope,\n  getIsolationScope,\n  getRootSpan,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  setCapturedScopesOnSpan,\n  spanToJSON,\n} from '@sentry/core';\nimport { getScopesFromContext } from '@sentry/opentelemetry';\nimport { ATTR_NEXT_ROUTE, ATTR_NEXT_SPAN_NAME, ATTR_NEXT_SPAN_TYPE } from '../common/nextSpanAttributes';\nimport { addHeadersAsAttributes } from '../common/utils/addHeadersAsAttributes';\nimport { dropMiddlewareTunnelRequests } from '../common/utils/dropMiddlewareTunnelRequests';\nimport { maybeEnhanceServerComponentSpanName } from '../common/utils/tracingUtils';\n\n/**\n * Handles the on span start event for Next.js spans.\n * This function is used to enhance the span with additional information such as the route, the method, the headers, etc.\n * It is called for every span that is started by Next.js.\n * @param span The span that is starting.\n */\nexport function handleOnSpanStart(span: Span): void {\n  const spanAttributes = spanToJSON(span).data;\n  const rootSpan = getRootSpan(span);\n  const rootSpanAttributes = spanToJSON(rootSpan).data;\n  const isRootSpan = span === rootSpan;\n\n  dropMiddlewareTunnelRequests(span, spanAttributes);\n\n  // What we do in this glorious piece of code, is hoist any information about parameterized routes from spans emitted\n  // by Next.js via the `next.route` attribute, up to the transaction by setting the http.route attribute.\n  if (typeof spanAttributes?.[ATTR_NEXT_ROUTE] === 'string') {\n    // Only hoist the http.route attribute if the transaction doesn't already have it\n    if (\n      // eslint-disable-next-line deprecation/deprecation\n      (rootSpanAttributes?.[ATTR_HTTP_REQUEST_METHOD] || rootSpanAttributes?.[SEMATTRS_HTTP_METHOD]) &&\n      !rootSpanAttributes?.[ATTR_HTTP_ROUTE]\n    ) {\n      const route = spanAttributes[ATTR_NEXT_ROUTE].replace(/\\/route$/, '');\n      rootSpan.updateName(route);\n      rootSpan.setAttribute(ATTR_HTTP_ROUTE, route);\n      // Preserving the original attribute despite internally not depending on it\n      rootSpan.setAttribute(ATTR_NEXT_ROUTE, route);\n    }\n  }\n\n  if (spanAttributes?.[ATTR_NEXT_SPAN_TYPE] === 'Middleware.execute') {\n    const middlewareName = spanAttributes[ATTR_NEXT_SPAN_NAME];\n    if (typeof middlewareName === 'string') {\n      rootSpan.updateName(middlewareName);\n      rootSpan.setAttribute(ATTR_HTTP_ROUTE, middlewareName);\n      rootSpan.setAttribute(ATTR_NEXT_SPAN_NAME, middlewareName);\n    }\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, 'auto');\n  }\n\n  // We want to skip span data inference for any spans generated by Next.js. Reason being that Next.js emits spans\n  // with patterns (e.g. http.server spans) that will produce confusing data.\n  if (spanAttributes?.[ATTR_NEXT_SPAN_TYPE] !== undefined) {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, 'auto');\n  }\n\n  if (isRootSpan) {\n    const headers = getIsolationScope().getScopeData().sdkProcessingMetadata?.normalizedRequest?.headers;\n    addHeadersAsAttributes(headers, rootSpan);\n  }\n\n  // We want to fork the isolation scope for incoming requests\n  if (spanAttributes?.[ATTR_NEXT_SPAN_TYPE] === 'BaseServer.handleRequest' && isRootSpan) {\n    const scopes = getCapturedScopesOnSpan(span);\n\n    const isolationScope = (scopes.isolationScope || getIsolationScope()).clone();\n    const scope = scopes.scope || getCurrentScope();\n\n    const currentScopesPointer = getScopesFromContext(context.active());\n    if (currentScopesPointer) {\n      currentScopesPointer.isolationScope = isolationScope;\n    }\n\n    setCapturedScopesOnSpan(span, scope, isolationScope);\n  }\n\n  maybeEnhanceServerComponentSpanName(span, spanAttributes, rootSpanAttributes);\n}\n"],"names":[],"mappings":";;;;;;;;;AAkBA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,iBAAiB,CAAC,IAAI,EAAc;AACpD,EAAE,MAAM,iBAAiB,UAAU,CAAC,IAAI,CAAC,CAAC,IAAI;AAC9C,EAAE,MAAM,QAAA,GAAW,WAAW,CAAC,IAAI,CAAC;AACpC,EAAE,MAAM,qBAAqB,UAAU,CAAC,QAAQ,CAAC,CAAC,IAAI;AACtD,EAAE,MAAM,UAAA,GAAa,IAAA,KAAS,QAAQ;;AAEtC,EAAE,4BAA4B,CAAC,IAAI,EAAE,cAAc,CAAC;;AAEpD;AACA;AACA,EAAE,IAAI,OAAO,cAAc,GAAG,eAAe,CAAA,KAAM,QAAQ,EAAE;AAC7D;AACA,IAAI;AACJ;AACA,MAAM,CAAC,kBAAkB,GAAG,wBAAwB,CAAA,IAAK,kBAAkB,GAAG,oBAAoB,CAAC;AACnG,MAAM,CAAC,kBAAkB,GAAG,eAAe;AAC3C,MAAM;AACN,MAAM,MAAM,KAAA,GAAQ,cAAc,CAAC,eAAe,CAAC,CAAC,OAAO,CAAC,UAAU,EAAE,EAAE,CAAC;AAC3E,MAAM,QAAQ,CAAC,UAAU,CAAC,KAAK,CAAC;AAChC,MAAM,QAAQ,CAAC,YAAY,CAAC,eAAe,EAAE,KAAK,CAAC;AACnD;AACA,MAAM,QAAQ,CAAC,YAAY,CAAC,eAAe,EAAE,KAAK,CAAC;AACnD,IAAI;AACJ,EAAE;;AAEF,EAAE,IAAI,cAAc,GAAG,mBAAmB,CAAA,KAAM,oBAAoB,EAAE;AACtE,IAAI,MAAM,cAAA,GAAiB,cAAc,CAAC,mBAAmB,CAAC;AAC9D,IAAI,IAAI,OAAO,cAAA,KAAmB,QAAQ,EAAE;AAC5C,MAAM,QAAQ,CAAC,UAAU,CAAC,cAAc,CAAC;AACzC,MAAM,QAAQ,CAAC,YAAY,CAAC,eAAe,EAAE,cAAc,CAAC;AAC5D,MAAM,QAAQ,CAAC,YAAY,CAAC,mBAAmB,EAAE,cAAc,CAAC;AAChE,IAAI;AACJ,IAAI,IAAI,CAAC,YAAY,CAAC,gCAAgC,EAAE,MAAM,CAAC;AAC/D,EAAE;;AAEF;AACA;AACA,EAAE,IAAI,cAAc,GAAG,mBAAmB,CAAA,KAAM,SAAS,EAAE;AAC3D,IAAI,IAAI,CAAC,YAAY,CAAC,gCAAgC,EAAE,MAAM,CAAC;AAC/D,EAAE;;AAEF,EAAE,IAAI,UAAU,EAAE;AAClB,IAAI,MAAM,OAAA,GAAU,iBAAiB,EAAE,CAAC,YAAY,EAAE,CAAC,qBAAqB,EAAE,iBAAiB,EAAE,OAAO;AACxG,IAAI,sBAAsB,CAAC,OAAO,EAAE,QAAQ,CAAC;AAC7C,EAAE;;AAEF;AACA,EAAE,IAAI,cAAc,GAAG,mBAAmB,CAAA,KAAM,0BAAA,IAA8B,UAAU,EAAE;AAC1F,IAAI,MAAM,MAAA,GAAS,uBAAuB,CAAC,IAAI,CAAC;;AAEhD,IAAI,MAAM,cAAA,GAAiB,CAAC,MAAM,CAAC,cAAA,IAAkB,iBAAiB,EAAE,EAAE,KAAK,EAAE;AACjF,IAAI,MAAM,QAAQ,MAAM,CAAC,KAAA,IAAS,eAAe,EAAE;;AAEnD,IAAI,MAAM,oBAAA,GAAuB,oBAAoB,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC;AACvE,IAAI,IAAI,oBAAoB,EAAE;AAC9B,MAAM,oBAAoB,CAAC,cAAA,GAAiB,cAAc;AAC1D,IAAI;;AAEJ,IAAI,uBAAuB,CAAC,IAAI,EAAE,KAAK,EAAE,cAAc,CAAC;AACxD,EAAE;;AAEF,EAAE,mCAAmC,CAAC,IAAI,EAAE,cAAc,EAAE,kBAAkB,CAAC;AAC/E;;;;"}