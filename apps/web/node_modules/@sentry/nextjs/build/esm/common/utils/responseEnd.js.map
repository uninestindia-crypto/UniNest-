{"version":3,"file":"responseEnd.js","sources":["../../../../src/common/utils/responseEnd.ts"],"sourcesContent":["import type { Span } from '@sentry/core';\nimport { debug, fill, flush, GLOBAL_OBJ, setHttpStatus, vercelWaitUntil } from '@sentry/core';\nimport type { ServerResponse } from 'http';\nimport { DEBUG_BUILD } from '../debug-build';\nimport type { ResponseEndMethod, WrappedResponseEndMethod } from '../types';\n\n/**\n * Wrap `res.end()` so that it ends the span and flushes events before letting the request finish.\n *\n * Note: This wraps a sync method with an async method. While in general that's not a great idea in terms of keeping\n * things in the right order, in this case it's safe, because the native `.end()` actually *is* (effectively) async, and\n * its run actually *is* (literally) awaited, just manually so (which reflects the fact that the core of the\n * request/response code in Node by far predates the introduction of `async`/`await`). When `.end()` is done, it emits\n * the `prefinish` event, and only once that fires does request processing continue. See\n * https://github.com/nodejs/node/commit/7c9b607048f13741173d397795bac37707405ba7.\n *\n * Also note: `res.end()` isn't called until *after* all response data and headers have been sent, so blocking inside of\n * `end` doesn't delay data getting to the end user. See\n * https://nodejs.org/api/http.html#responseenddata-encoding-callback.\n *\n * @param span The span tracking the request\n * @param res: The request's corresponding response\n */\nexport function autoEndSpanOnResponseEnd(span: Span, res: ServerResponse): void {\n  const wrapEndMethod = (origEnd: ResponseEndMethod): WrappedResponseEndMethod => {\n    return function sentryWrappedEnd(this: ServerResponse, ...args: unknown[]) {\n      finishSpan(span, this);\n      return origEnd.call(this, ...args);\n    };\n  };\n\n  // Prevent double-wrapping\n  // res.end may be undefined during build when using `next export` to statically export a Next.js app\n  if (res.end && !(res.end as WrappedResponseEndMethod).__sentry_original__) {\n    fill(res, 'end', wrapEndMethod);\n  }\n}\n\n/** Finish the given response's span and set HTTP status data */\nexport function finishSpan(span: Span, res: ServerResponse): void {\n  setHttpStatus(span, res.statusCode);\n  span.end();\n}\n\n/**\n * Flushes pending Sentry events with a 2 second timeout and in a way that cannot create unhandled promise rejections.\n */\nexport async function flushSafelyWithTimeout(): Promise<void> {\n  try {\n    DEBUG_BUILD && debug.log('Flushing events...');\n    await flush(2000);\n    DEBUG_BUILD && debug.log('Done flushing events');\n  } catch (e) {\n    DEBUG_BUILD && debug.log('Error while flushing events:\\n', e);\n  }\n}\n\n/**\n * Uses platform-specific waitUntil function to wait for the provided task to complete without blocking.\n */\nexport function waitUntil(task: Promise<unknown>): void {\n  // If deployed on Cloudflare, use the Cloudflare waitUntil function to flush the events\n  if (isCloudflareWaitUntilAvailable()) {\n    cloudflareWaitUntil(task);\n    return;\n  }\n\n  // otherwise, use vercel's\n  vercelWaitUntil(task);\n}\n\ntype MinimalCloudflareContext = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  waitUntil(promise: Promise<any>): void;\n};\n\n/**\n * Gets the Cloudflare context from the global object.\n * Relevant to opennext\n * https://github.com/opennextjs/opennextjs-cloudflare/blob/b53a046bd5c30e94a42e36b67747cefbf7785f9a/packages/cloudflare/src/cli/templates/init.ts#L17\n */\nfunction _getOpenNextCloudflareContext(): MinimalCloudflareContext | undefined {\n  const openNextCloudflareContextSymbol = Symbol.for('__cloudflare-context__');\n\n  return (\n    GLOBAL_OBJ as typeof GLOBAL_OBJ & {\n      [openNextCloudflareContextSymbol]?: {\n        ctx: MinimalCloudflareContext;\n      };\n    }\n  )[openNextCloudflareContextSymbol]?.ctx;\n}\n\n/**\n * Function that delays closing of a Cloudflare lambda until the provided promise is resolved.\n */\nexport function cloudflareWaitUntil(task: Promise<unknown>): void {\n  _getOpenNextCloudflareContext()?.waitUntil(task);\n}\n\n/**\n * Checks if the Cloudflare waitUntil function is available globally.\n */\nexport function isCloudflareWaitUntilAvailable(): boolean {\n  return typeof _getOpenNextCloudflareContext()?.waitUntil === 'function';\n}\n"],"names":[],"mappings":";;;AA4CA;AACA;AACA;AACO,eAAe,sBAAsB,GAAkB;AAC9D,EAAE,IAAI;AACN,IAAI,eAAe,KAAK,CAAC,GAAG,CAAC,oBAAoB,CAAC;AAClD,IAAI,MAAM,KAAK,CAAC,IAAI,CAAC;AACrB,IAAI,eAAe,KAAK,CAAC,GAAG,CAAC,sBAAsB,CAAC;AACpD,EAAE,CAAA,CAAE,OAAO,CAAC,EAAE;AACd,IAAI,WAAA,IAAe,KAAK,CAAC,GAAG,CAAC,gCAAgC,EAAE,CAAC,CAAC;AACjE,EAAE;AACF;;AAEA;AACA;AACA;AACO,SAAS,SAAS,CAAC,IAAI,EAA0B;AACxD;AACA,EAAE,IAAI,8BAA8B,EAAE,EAAE;AACxC,IAAI,mBAAmB,CAAC,IAAI,CAAC;AAC7B,IAAI;AACJ,EAAE;;AAEF;AACA,EAAE,eAAe,CAAC,IAAI,CAAC;AACvB;;AAOA;AACA;AACA;AACA;AACA;AACA,SAAS,6BAA6B,GAAyC;AAC/E,EAAE,MAAM,kCAAkC,MAAM,CAAC,GAAG,CAAC,wBAAwB,CAAC;;AAE9E,EAAE,OAAO;AACT,IAAI;;AAKJ,IAAI,+BAA+B,CAAC,EAAE,GAAG;AACzC;;AAEA;AACA;AACA;AACO,SAAS,mBAAmB,CAAC,IAAI,EAA0B;AAClE,EAAE,6BAA6B,EAAE,EAAE,SAAS,CAAC,IAAI,CAAC;AAClD;;AAEA;AACA;AACA;AACO,SAAS,8BAA8B,GAAY;AAC1D,EAAE,OAAO,OAAO,6BAA6B,EAAE,EAAE,SAAA,KAAc,UAAU;AACzE;;;;"}