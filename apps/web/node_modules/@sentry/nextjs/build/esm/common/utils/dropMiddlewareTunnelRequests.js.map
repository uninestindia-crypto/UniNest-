{"version":3,"file":"dropMiddlewareTunnelRequests.js","sources":["../../../../src/common/utils/dropMiddlewareTunnelRequests.ts"],"sourcesContent":["import { SEMATTRS_HTTP_TARGET } from '@opentelemetry/semantic-conventions';\nimport { GLOBAL_OBJ, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, type Span, type SpanAttributes } from '@sentry/core';\nimport { isSentryRequestSpan } from '@sentry/opentelemetry';\nimport { ATTR_NEXT_SPAN_TYPE } from '../nextSpanAttributes';\nimport { TRANSACTION_ATTR_SHOULD_DROP_TRANSACTION } from '../span-attributes-with-logic-attached';\n\nconst globalWithInjectedValues = GLOBAL_OBJ as typeof GLOBAL_OBJ & {\n  _sentryRewritesTunnelPath?: string;\n};\n\n/**\n * Drops spans for tunnel requests from middleware or fetch instrumentation.\n * This catches both:\n * 1. Requests to the local tunnel route (before rewrite)\n * 2. Requests to Sentry ingest (after rewrite)\n */\nexport function dropMiddlewareTunnelRequests(span: Span, attrs: SpanAttributes | undefined): void {\n  // Only filter middleware spans or HTTP fetch spans\n  const isMiddleware = attrs?.[ATTR_NEXT_SPAN_TYPE] === 'Middleware.execute';\n  // The fetch span could be originating from rewrites re-writing a tunnel request\n  // So we want to filter it out\n  const isFetchSpan = attrs?.[SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN] === 'auto.http.otel.node_fetch';\n\n  // If the span is not a middleware span or a fetch span, return\n  if (!isMiddleware && !isFetchSpan) {\n    return;\n  }\n\n  // Check if this is either a tunnel route request or a Sentry ingest request\n  const isTunnel = isTunnelRouteSpan(attrs || {});\n  const isSentry = isSentryRequestSpan(span);\n\n  if (isTunnel || isSentry) {\n    // Mark the span to be dropped\n    span.setAttribute(TRANSACTION_ATTR_SHOULD_DROP_TRANSACTION, true);\n  }\n}\n\n/**\n * Checks if a span's HTTP target matches the tunnel route.\n */\nfunction isTunnelRouteSpan(spanAttributes: Record<string, unknown>): boolean {\n  const tunnelPath = globalWithInjectedValues._sentryRewritesTunnelPath || process.env._sentryRewritesTunnelPath;\n  if (!tunnelPath) {\n    return false;\n  }\n\n  // eslint-disable-next-line deprecation/deprecation\n  const httpTarget = spanAttributes[SEMATTRS_HTTP_TARGET];\n\n  if (typeof httpTarget === 'string') {\n    // Extract pathname from the target (e.g., \"/tunnel?o=123&p=456\" -> \"/tunnel\")\n    const pathname = httpTarget.split('?')[0] || '';\n\n    return pathname.startsWith(tunnelPath);\n  }\n\n  return false;\n}\n"],"names":[],"mappings":";;;;;;AAMA,MAAM,wBAAA,GAA2B;;AAEjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,4BAA4B,CAAC,IAAI,EAAQ,KAAK,EAAoC;AAClG;AACA,EAAE,MAAM,eAAe,KAAK,GAAG,mBAAmB,CAAA,KAAM,oBAAoB;AAC5E;AACA;AACA,EAAE,MAAM,cAAc,KAAK,GAAG,gCAAgC,CAAA,KAAM,2BAA2B;;AAE/F;AACA,EAAE,IAAI,CAAC,gBAAgB,CAAC,WAAW,EAAE;AACrC,IAAI;AACJ,EAAE;;AAEF;AACA,EAAE,MAAM,WAAW,iBAAiB,CAAC,KAAA,IAAS,EAAE,CAAC;AACjD,EAAE,MAAM,QAAA,GAAW,mBAAmB,CAAC,IAAI,CAAC;;AAE5C,EAAE,IAAI,QAAA,IAAY,QAAQ,EAAE;AAC5B;AACA,IAAI,IAAI,CAAC,YAAY,CAAC,wCAAwC,EAAE,IAAI,CAAC;AACrE,EAAE;AACF;;AAEA;AACA;AACA;AACA,SAAS,iBAAiB,CAAC,cAAc,EAAoC;AAC7E,EAAE,MAAM,UAAA,GAAa,wBAAwB,CAAC,yBAAA,IAA6B,OAAO,CAAC,GAAG,CAAC,yBAAyB;AAChH,EAAE,IAAI,CAAC,UAAU,EAAE;AACnB,IAAI,OAAO,KAAK;AAChB,EAAE;;AAEF;AACA,EAAE,MAAM,UAAA,GAAa,cAAc,CAAC,oBAAoB,CAAC;;AAEzD,EAAE,IAAI,OAAO,UAAA,KAAe,QAAQ,EAAE;AACtC;AACA,IAAI,MAAM,QAAA,GAAW,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAA,IAAK,EAAE;;AAEnD,IAAI,OAAO,QAAQ,CAAC,UAAU,CAAC,UAAU,CAAC;AAC1C,EAAE;;AAEF,EAAE,OAAO,KAAK;AACd;;;;"}