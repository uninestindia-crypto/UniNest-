{"version":3,"file":"_error.js","sources":["../../../../src/common/pages-router-instrumentation/_error.ts"],"sourcesContent":["import { captureException, httpRequestToRequestData, withScope } from '@sentry/core';\nimport type { NextPageContext } from 'next';\nimport { flushSafelyWithTimeout, waitUntil } from '../utils/responseEnd';\n\ntype ContextOrProps = {\n  req?: NextPageContext['req'];\n  res?: NextPageContext['res'];\n  err?: NextPageContext['err'] | string;\n  pathname?: string;\n  statusCode?: number;\n};\n\n/**\n * Capture the exception passed by nextjs to the `_error` page, adding context data as appropriate.\n *\n * @param contextOrProps The data passed to either `getInitialProps` or `render` by nextjs\n */\nexport async function captureUnderscoreErrorException(contextOrProps: ContextOrProps): Promise<void> {\n  const { req, res, err } = contextOrProps;\n\n  // 404s (and other 400-y friends) can trigger `_error`, but we don't want to send them to Sentry\n  const statusCode = res?.statusCode || contextOrProps.statusCode;\n  if (statusCode && statusCode < 500) {\n    return Promise.resolve();\n  }\n\n  // In previous versions of the suggested `_error.js` page in which this function is meant to be used, there was a\n  // workaround for https://github.com/vercel/next.js/issues/8592 which involved an extra call to this function, in the\n  // custom error component's `render` method, just in case it hadn't been called by `getInitialProps`. Now that that\n  // issue has been fixed, the second call is unnecessary, but since it lives in user code rather than our code, users\n  // have to be the ones to get rid of it, and guaraneteedly, not all of them will. So, rather than capture the error\n  // twice, we just bail if we sense we're in that now-extraneous second call. (We can tell which function we're in\n  // because Nextjs passes `pathname` to `getInitialProps` but not to `render`.)\n  if (!contextOrProps.pathname) {\n    return Promise.resolve();\n  }\n\n  withScope(scope => {\n    if (req) {\n      const normalizedRequest = httpRequestToRequestData(req);\n      scope.setSDKProcessingMetadata({ normalizedRequest });\n    }\n\n    // If third-party libraries (or users themselves) throw something falsy, we want to capture it as a message (which\n    // is what passing a string to `captureException` will wind up doing)\n    captureException(err || `_error.js called with falsy error (${err})`, {\n      mechanism: {\n        type: 'auto.function.nextjs.underscore_error',\n        handled: false,\n        data: {\n          function: '_error.getInitialProps',\n        },\n      },\n    });\n  });\n\n  waitUntil(flushSafelyWithTimeout());\n}\n"],"names":[],"mappings":";;;AAYA;AACA;AACA;AACA;AACA;AACO,eAAe,+BAA+B,CAAC,cAAc,EAAiC;AACrG,EAAE,MAAM,EAAE,GAAG,EAAE,GAAG,EAAE,GAAA,EAAI,GAAI,cAAc;;AAE1C;AACA,EAAE,MAAM,aAAa,GAAG,EAAE,UAAA,IAAc,cAAc,CAAC,UAAU;AACjE,EAAE,IAAI,UAAA,IAAc,UAAA,GAAa,GAAG,EAAE;AACtC,IAAI,OAAO,OAAO,CAAC,OAAO,EAAE;AAC5B,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,IAAI,CAAC,cAAc,CAAC,QAAQ,EAAE;AAChC,IAAI,OAAO,OAAO,CAAC,OAAO,EAAE;AAC5B,EAAE;;AAEF,EAAE,SAAS,CAAC,KAAA,IAAS;AACrB,IAAI,IAAI,GAAG,EAAE;AACb,MAAM,MAAM,iBAAA,GAAoB,wBAAwB,CAAC,GAAG,CAAC;AAC7D,MAAM,KAAK,CAAC,wBAAwB,CAAC,EAAE,iBAAA,EAAmB,CAAC;AAC3D,IAAI;;AAEJ;AACA;AACA,IAAI,gBAAgB,CAAC,GAAA,IAAO,CAAC,mCAAmC,EAAE,GAAG,CAAC,CAAC,CAAC,EAAE;AAC1E,MAAM,SAAS,EAAE;AACjB,QAAQ,IAAI,EAAE,uCAAuC;AACrD,QAAQ,OAAO,EAAE,KAAK;AACtB,QAAQ,IAAI,EAAE;AACd,UAAU,QAAQ,EAAE,wBAAwB;AAC5C,SAAS;AACT,OAAO;AACP,KAAK,CAAC;AACN,EAAE,CAAC,CAAC;;AAEJ,EAAE,SAAS,CAAC,sBAAsB,EAAE,CAAC;AACrC;;;;"}